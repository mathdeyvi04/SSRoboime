#pragma once

#include <iostream>
#include <cstring>

unsigned char exemplo_de_mensagem[] = {
	0x28, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x28, 0x6E, 0x6F, 0x77, 0x20, 0x35, 0x36, 0x2E, 0x37, 0x32,
    0x29, 0x29, 0x28, 0x47, 0x53, 0x20, 0x28, 0x73, 0x6C, 0x20, 0x30, 0x29, 0x20, 0x28, 0x73, 0x72,
    0x20, 0x30, 0x29, 0x20, 0x28, 0x74, 0x20, 0x30, 0x2E, 0x30, 0x30, 0x29, 0x20, 0x28, 0x70, 0x6D,
    0x20, 0x42, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x4B, 0x69, 0x63, 0x6B, 0x4F, 0x66, 0x66, 0x29, 0x29,
    0x28, 0x47, 0x59, 0x52, 0x20, 0x28, 0x6E, 0x20, 0x74, 0x6F, 0x72, 0x73, 0x6F, 0x29, 0x20, 0x28,
    0x72, 0x74, 0x20, 0x2D, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x2D, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x30,
    0x2E, 0x30, 0x30, 0x29, 0x29, 0x28, 0x41, 0x43, 0x43, 0x20, 0x28, 0x6E, 0x20, 0x74, 0x6F, 0x72,
    0x73, 0x6F, 0x29, 0x20, 0x28, 0x61, 0x20, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x30, 0x2E, 0x30, 0x30,
    0x20, 0x30, 0x2E, 0x30, 0x30, 0x29, 0x29, 0x28, 0x48, 0x4A, 0x20, 0x28, 0x6E, 0x20, 0x68, 0x6A,
    0x31, 0x29, 0x20, 0x28, 0x61, 0x78, 0x20, 0x30, 0x2E, 0x30, 0x30, 0x29, 0x29, 0x28, 0x48, 0x4A,
    0x20, 0x28, 0x6E, 0x20, 0x68, 0x6A, 0x32, 0x29, 0x20, 0x28, 0x61, 0x78, 0x20, 0x2D, 0x30, 0x2E,
    0x30, 0x30, 0x29, 0x29, 0x28, 0x53, 0x65, 0x65, 0x20, 0x28, 0x47, 0x31, 0x4C, 0x20, 0x28, 0x70,
    0x6F, 0x6C, 0x20, 0x32, 0x32, 0x2E, 0x35, 0x37, 0x20, 0x34, 0x31, 0x2E, 0x31, 0x39, 0x20, 0x2D,
    0x30, 0x2E, 0x39, 0x34, 0x29, 0x29, 0x20, 0x28, 0x47, 0x32, 0x4C, 0x20, 0x28, 0x70, 0x6F, 0x6C,
    0x20, 0x32, 0x30, 0x2E, 0x39, 0x37, 0x20, 0x34, 0x34, 0x2E, 0x37, 0x33, 0x20, 0x2D, 0x30, 0x2E,
    0x39, 0x34, 0x29, 0x29, 0x20, 0x28, 0x47, 0x32, 0x52, 0x20, 0x28, 0x70, 0x6F, 0x6C, 0x20, 0x32,
    0x31, 0x2E, 0x33, 0x34, 0x20, 0x2D, 0x34, 0x35, 0x2E, 0x35, 0x39, 0x20, 0x2D, 0x30, 0x2E, 0x37,
    0x34, 0x29, 0x29, 0x20, 0x28, 0x47, 0x31, 0x52, 0x20, 0x28, 0x70, 0x6F, 0x6C, 0x20, 0x32, 0x32,
    0x2E, 0x38, 0x35, 0x20, 0x2D, 0x34, 0x32, 0x2E, 0x30, 0x34, 0x20, 0x2D, 0x30, 0x2E, 0x37, 0x31,
    0x29, 0x29, 0x20, 0x28, 0x46, 0x31, 0x4C, 0x20, 0x28, 0x70, 0x6F, 0x6C, 0x20, 0x32, 0x39, 0x2E,
    0x39, 0x31, 0x20, 0x32, 0x39, 0x2E, 0x31, 0x38, 0x20, 0x2D, 0x32, 0x2E, 0x31, 0x30, 0x29, 0x29,
    0x20, 0x28, 0x46, 0x31, 0x52, 0x20, 0x28, 0x70, 0x6F, 0x6C, 0x20, 0x33, 0x30, 0x2E, 0x31, 0x39,
    0x20, 0x2D, 0x33, 0x30, 0x2E, 0x33, 0x33, 0x20, 0x2D, 0x32, 0x2E, 0x30, 0x30, 0x29, 0x29, 0x20,
};
int size = 12;

/**
 * 
 */
class SimulatorParser {
private:
	int size = 0; ///> Para mantermos informação do comprimento total do buffer
	int idx = 0; ///> Para mantermos informação de onde estamos no buffer, sem fazer alterações no ponteiro.
	int temp_int = 0; ///> Para fazermos operações temporárias
	int temp_start_flag = 0; ///> Para marcamos início de uma flag
	int temp_end_flag = 0; ///> Para marcamos o final de uma flag

	/**
	 * @brief Utilizará uma lógica específica para printar os caracteres. Não há qualquer tipo de verificação.
	 * @param buffer Ponteiro para buffer de mensagem.
	 * @param length Comprimento de Leitura.
	 * @return Será printado na tela os caracteres correspondentes, no estilo C, usando printf.
	 * @details
	 * Exemplo: buffer = "arroz", imprimir(buffer, 3) = "arr"
	 */
	inline
	void
	imprimir(
		const unsigned char* buffer,
		int length
	) const { printf("%.*s", length, buffer); }

	/**
	 * @brief Verifica se o buffer de hexadecimais é igual à sequência de caracteres.
	 * @param buffer Ponteiro para buffer de comparação
	 * @param pattern Sequência de caracteres que será verificada.	
	 * @return True se for a mesma sequência, False, caso contrário.
	 */
	inline
	bool
	bytescmp(
		const unsigned char* buffer,
		const char* pattern
	) const { return std::equal(buffer, buffer + strlen(pattern), pattern); }

	/**
	 * @brief Indentificará a próxima flag
	 * @param buffer Ponteiro para Mensagem
	 * @return Inteiro do quanto percorremos no buffer
	 * @details
	 * Percorre até achar '(', inicia captura da flag e finaliza ao encontrar ' '.
	 * start_flag marcará o primeiro caractere e o end o último.
	 */
	int
	get_next_tag(
		const unsigned char* buffer
	){
		this->temp_int = 1;
		printf("\nPrimeiro elemento do buffer: '%c'", buffer[this->temp_int - 1]);
		while( buffer[this->temp_int - 1] != '(' ){ this->temp_int++; if((this->temp_int - 1) > this->size){ return -1;}}

		// Redefinimos os valores
		this->temp_start_flag = this->temp_int;
		printf("\nPrimeiro elemento da flag: '%c'", buffer[this->temp_start_flag]);
		while( buffer[this->temp_int + 1] != ' ' ){ this->temp_int++; if((this->temp_int + 1) > this->size){ return -1;}}
		this->temp_end_flag = this->temp_int;
		printf("\nÚltimo elemento da flag: '%c'", buffer[this->temp_end_flag]);

		return this->temp_int + 2; // Pulamos para o caractere à frente do ' '
	}

public:

	/**
	 * @brief Realizará o parsing das informações recebidas.
	 * @param buffer Ponteiro para buffer da mensagem original.
	 * @param size Comprimento total do buffer. 
	 */
	void
	parsing(
		const unsigned char* buffer,
		int size
	){
		// ------------------------
		// Inicializações
		this->size = size;

		while(
			this->idx < this->size
		){

			this->temp_int = get_next_tag(buffer + this->idx);
			if( this->temp_int == -1 ){ printf("Chegamos ao final da mensagem de forma abrupta."); return; }

			printf("\nidx = %d \t start = %d \t end = %d\n", this->idx, this->temp_start_flag, this->temp_end_flag);
			imprimir(buffer + this->idx + this->temp_start_flag, this->temp_end_flag - this->temp_start_flag + 1);
			this->idx += this->temp_int;
		}
	}
};
